A Sneak Peak into Super Optimized Code in JS Frameworks

React - Fibernode
Angular- ViewNode

Locating value of a property in memory is a complicated process

V8 engines maintains shapes
Transition Chains

Optimization through inline cache
function getX(0){

}

feedbackVector - state shape prop offset
Monomorphic access to objects - single shape will be intenally cached in 

Frameworks enforce same shape for fiber and view nodes 

Bit Fields for classification React enforces side effects in bit fields

Bloom Filters- NO or May be filters ( Probailitistic filters)

Angular Hiearchial injectors

http://bit.ly/reverse-engineering
http://bit.ly/change-detection-in-angular
http://bit.ly/react-inside-fiber

Chrome Dev Tools 
chrome://version 
Chrome Dev Tools -> Audits -> 

Oppurtunities Diagnostics Passed Audits

Audit your Page
Use Report to find Improvements
Introduce Changes one by one
Audit after each change

const compression = require('compression')
app.use(comporession)

Eliminiate third party dependencies

Memory Leaks
Heap --?
Profiles CPU Profile 

Heap Allocatins and Heap Snapshots\

codeschool.com/courses/discover-devtools
developers.google.com/web/tools/chrome-devtools


Crank Shaft - Optimizing compiler in v8

Ignition + TurboFan

Microbench marks

.1 Content Delivery Network  CloundFare and Akamai  DNS Requests
.2 Images
.3 Priorotize Critical Rendering Pat Render Tree, DOM Tree, CSSOM Tree
.4 Asset Caching Cache-Control: max-age 
.5 Optimize Animations 

const animate = timestamp 
requestAnimationFrame(animate)

el.animate( )

Promise.all(
    el.getAnimationas().map()
)

WeAnimationsAPI

Top 5 tips for front end optimizations
